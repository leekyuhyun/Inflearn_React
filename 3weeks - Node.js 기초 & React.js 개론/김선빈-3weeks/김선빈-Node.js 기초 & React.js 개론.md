# \[ Node.js 기초 React.js 개론 ]
## Node.js란?
> 웹 브라우저 밖에서 자바스크립트 코드를 실행할 수 있게 해주는 환경(런타임)

![[Nodejs란.png]]

### Node.js는 왜 만든 걸까?
**JavaScript**는 웹 페이지 내부에 필요한 아주 단순한 기능만을 개발하기 위해 만들어진 스크립트 언어인데 이를 범용적으로 사용할 수 있도록 도와주는 **JavaScript의 실행 환경**, 즉 런타임입니다.

### 프로젝트(Project)
![[패키지.png]]

### 모듈(Module)이란?
간단한 웹 쇼핑몰을 만들 때 복잡한 기능을 하나의 파일에만 작성하면 코드의 양의 어마어마할 것입니다. 이때 버그나 기능을 개선하려고 할 때 수정해야 되는 곳이 어디인지 매번 찾아가야 되기 때문에 **가독성**이 떨어지게 됩니다.

![[모듈이란.png]]
그럴 때 위와 같이 기능별로 파일을 깔끔하게 분리하는 게 일반적입니다. 이때 `user.js`, `cart.js` 또는 `payment.js` 파일처럼 기능별로 나뉘어진 각각의 자바스크립트 파일들을 **모듈**이라고 부릅니다.

### 모듈 시스템(Module System)이란?
> 모듈을 생성하고, 불러오고, 사용하는 등의 모듈을 다루는 다양한 기능을 제공하는 시스템

JavaScript의 모듈 시스템들
- Common JS (CJS)
- ES Module (ESM)
- AMD
- UMD

### 모듈 시스템 CommonJS 예제 코드
```javascript title="src/index.js"
const { add, sub } = require("./math");
console.log(add(1, 2));
console.log(sub(1, 2));
```

```javascript title="src/math.js"
// math 모듈
function add(a, b) { return a + b; }
function sub(a, b) { return a - b; }
module.exports = {
  // vaule 값으로 사용되는 변수의 이름과 키 값을 같을 경우
  // 함수 이름만 명시해줘도 됨
  // add: add,
  // sub: sub,
  add,
  sub,
};
```

### 모듈 시스템 ESModule 예제 코드
```javascript title="src/index.js"
import mul, { add, sub } from "./math.js";
console.log(add(1, 2));
console.log(sub(1, 2));
console.log(mul(2, 3));
```

```javascript title="src/math.js"
// math 모듈
export function add(a, b) { return a + b; }
export function sub(a, b) { return a - b; }
export default function multiply(a, b) { return a * b; }
```

### 라이브러리란?
> 프로그램을 개발할 때 필요한 다양한 기능들을 미리 만들어 모듈화 해놓은 것

**라이브러리**를 사용하게 되면 날짜, 수학, 그래픽 라이브러리 등 복잡하거나 귀찮은 기능들을 일일이 만들 필요가 없어집니다.

```json
// package.json
"dependencies": {
  "randomcolor": "^0.6.2"
}

// package-lock.json
"node_modules/randomcolor": {
  "version": "0.6.2",
  ...
}
```
라이브러리를 설치하면 `package.json`의 **dependencies**에 추가됩니다. 이때 버전에 붙는 **^ 기호**는 마이너 업데이트 등 호환 가능한 버전까지 허용한다는 뜻입니다.

반면, **`package-lock.json`**에는 **실제로 설치된 구체적인 버전**이 기록됩니다. 덕분에 나중에 다시 설치하거나 팀원과 협업할 때, 버전 차이 없이 완벽하게 동일한 환경을 구축할 수 있습니다.

> 라이브러리를 불러올 때는 경로가 아닌 이름만 명시하면 됨
> `import randomColor from "randomcolor";`

## React.js란?
> Meta(Facebook)이 개발한 오픈소스 JavaScript 라이브러리
> 대규모 웹 서비스의 UI를 더 편하게 개발하기 위해 만들어진 기술

### React.js로 만들어진 서비스들
- 넷플릭스, 페이스북, 인스타그램, 노션 등
- 26년 2월 현재, 국내 React 사용 사이트 수는 BuiltWith 통계 기준 약 71만 개

## React 특징 1. 컴포넌트를 기반으로 UI를 표현한다
> 컴포넌트(Component)란 우리말로 "구성요소"라는 뜻
> 화면을 구성하는 요소, UI를 구성하는 요소를 말함

![[컴포넌트.png]]
리액트에서는 웹페이지를 하나의 거대한 통으로 만들지 않고, 헤더(`Header.js`), 메인(`Main.js`), 푸터(`Footer.js`)처럼 각 영역을 독립적인 **컴포넌트(Component)** 단위로 분리해 모듈화할 수 있습니다. 이렇게 나뉜 부품들을 마치 레고 블록을 조립하듯 하나로 합쳐 완성합니다. 코드 관리도 쉬워지고, 재사용성도 극대화됩니다.

```html
<!-- 헤더를 사용하는 모든 페이지에 HTML로 직접 헤더를 마크업해줘야 함 ->
<!-- 이러한 중복 코드가 발생하면 유지보수에 좋지 않음 -->
<header>
  <h3>홈페이지</h3>
  <nav>
    <a href="./index.html">홈</a>
    <a href="./mypage.html">마이 페이지</a>
  </nav>
</header>
```

## React 특징 2. 화면 업데이트 구현이 쉽다
> 업데이트란? 사용자의 행동(클릭, 드래그)에 따라 웹페이지가 스스로 모습을 바꿔 상호작용 하는 것

리액트는 **"어떻게(How)"**가 아닌 **"무엇을(What)"**에 집중하는 선언형 방식을 채택합니다.

| 구분  | 명령형(Imperative)            | 선언형(Declarative)  |
| --- | -------------------------- | ----------------- |
| 핵심  | 모든 과정을 일일이 설명함             | 원하는 결과만 명시함       |
| 비유  | "가스레인지 켜고, 면 삶고, 소스 부어주세요" | "토마토 파스타 하나 주세요!" |
| 언어  | 일반 JavaScript (DOM 조작)     | React             |
| 장점  | 세밀한 제어가 가능                 | 코드가 간결하고 읽기 쉬움    |

**선언형 프로그래밍 방식**은 목적만 명시하면 되기 때문에 코드가 비교적 간결하고, **명령형 프로그래밍 방식**은 목적을 이루기 위한 모든 과정을 설명하기 때문에 코드가 비교적 길고 복잡해질 수 있음

![[State.png]]

리액트 컴포넌트에는 **State**라고 불리는 특별한 '기억 장치'가 있습니다.
> State란? 사용자와의 상호작용을 통해 언제든지 바뀔 수 있는 데이터 (예: 좋아요 수, 입력한 글자 등)

리액트가 화면을 업데이트하는 과정은 다음과 같습니다.
1. **State 변경**: 사용자가 버튼을 클릭해 State 값이 바뀜
2. **감지**: 리액트가 State가 변했다는 것을 알아차림
3. **자동 렌더링**: 바뀐 State 값에 맞춰 UI를 스스로 다시 그림

> "우리가 데이터(State)만 바꿔주면 화면을 다시 그리는 복잡한 과정은 리액트가 알아서 다 해줘요."

단순하게 핵심만 이야기하면 리액트에서는 업데이트를 위한 복잡한 동작을 직접 정의할 필요 없이 **특정 변수의 값을 바꾸는 것**만으로도 **화면을 업데이트** 시킬 수 있습니다.

## React 특징 3. 화면 업데이트가 빠르게 처리된다
웹페이지는 단순히 보여주는 것을 넘어, 끊임없이 변화합니다. 리액트가 왜 빠른지 이해하려면, 먼저 브라우저가 화면을 그리는 기본 원리인 CRP를 알아야 합니다.

### 브라우저의 렌더링 과정(Critical Rendering Path)
![[브라우저의 렌더링 과정.png]]

> 브라우저가 HTML, CSS 파일을 받아서 화면에 픽셀을 찍기까지의 여정으로 프론트엔드 개발의 핵심 기본 개념

![[DOM.png]]

1. **객체 생성 (DOM & CSSOM):**
  - **DOM:** HTML 코드를 브라우저가 이해할 수 있는 객체로 변환
  - **CSSOM(CSS Object Model):** CSS를 브라우저가 이해할 수 있는 형태로 변환
2. **설계도 완성 (Render Tree):**
  - DOM과 CSSOM을 합쳐 실제 화면에 보여질 요소들만 모은 설계도를 생성
3. **배치 잡기 (Layout):**
  - 설계도를 바탕으로 각 요소가 화면의 **어느 위치에, 어느 정도 크기**로 들어갈지 계산
4. **색칠하기 (Painting):**
  - 계산된 위치에 실제 픽셀을 채워 넣어 화면을 완성

### 리플로우(Reflow)와 리페인트(Repaint)
문제는 자바스크립트로 DOM을 직접 수정할 때 발생합니다.  **DOM이 하나라도 바뀌면 브라우저는 위 과정을 처음부터 다시 시작합니다.**
- **리플로우 (Reflow):** 레이아웃(배치)을 다시 계산하는 과정 (매우 무거움)
- **리페인트 (Repaint):** 바뀐 배치를 화면에 다시 그리는 과정 (무거움)

> 요약: 화면이 한 번 바뀔 때마다 브라우저는 "계산기"와 "붓"을 새로 만들어야 하는데 이 과정이 반복되면 웹사이트는 버벅거리고 성능이 저하됨

### 직접적인 DOM 조작의 위험성
자바스크립트로 DOM을 직접 수정하는 것이 왜 성능에 치명적인지 아래 예시 코드를 통해 확인할 수 있습니다.
```html
<script>
  function onClick() {
    const $ul = document.getElementById("ul");
    for (let i = 0; i < 3000; i++) {
      $ul.innerHTML += `<li>${i}</li>`;
    }
  }
</script>
<body>
  <button onclick="onClick()">리스트 추가하기</button>
  <ul id="ul"></ul>
</body>
```

**성능 분석 결과**
- **반복적인 DOM 수정**: `innerHTML +=`를 통해 3,000번이나 리스트를 추가함
- **CRP의 무한 반복**: 리스트가 하나 추가될 때마다 브라우저는 **Layout(리플로우)과 Paint(리페인트) 과정을 처음부터 다시 수행**함
- **브라우저 마비**: 이 과정이 완료될 때까지 총 **4,500ms(4.5초)**가 소요됨

> **결과는 "프리징(Freezing)" 현상 발생** 사용자가 버튼을 누른 후 4.5초 동안 웹사이트는 어떠한 클릭도, 스크롤도 할 수 없는 '먹통' 상태가 됩니다. 단 3,000개의 목록을 추가했을 뿐인데 말이죠.

직접적인 DOM 조작이 불가피하다면, **수정 횟수를 최소한으로 줄이는 것**만으로도 성능을 개선할 수 있습니다.
```html
<script>
  function onClick() {
    const $ul = document.getElementById("ul");
    let list = "";
    for (let i = 0; i < 3000; i ++) {
      list += `<li>${i}</li>`;
    }
    $ul.innerHTML = list;
  }
</script>
<body>
  <button onclick="onClick()">리스트 추가하기</button>
  <ul id="ul"></ul>
</body>
```

**성능 분석 결과**
- **DOM 수정 횟수**: 3,000번 -> 딱 1번
- **소요 시간**: 4,500ms -> 250ms

반복문 안에서 매번 브라우저(CRP)를 실행시키는 게 아닌, 메모리(변수) 상에서 모든 계산을 끝낸 뒤 **최종 결과만 브라우저에 전달**하는 방식

### 리액트가 업데이트를 빠르게 처리하는 비결: 가상 돔(Virtual DOM)
결론적으로 자바스크립트로 DOM을 직접 수정할 때는 **DOM 수정 횟수를 최소화**하는 것이 성능의 핵심입니다. 업데이트를 하나씩 반영하는 게 아니라, 다 모아두었다가 **한 번에 반영**하도록 신경 써야 하죠.

이 번거로운 과정을 리액트는 '가상 돔'을 통해 자동으로 처리해 줍니다.

> 가상 돔(Virtual DOM)이란? 실제 브라우저가 렌더링하는 DOM을 자바스크립트 객체로 가볍게 복사해놓은 '복제판'

![[Virtual DOM.png]]
- **특징:** 실제 화면을 그리는 게 아니라 자바스크립트 객체일 뿐이라서 수정 속도가 매우 빠릅니다.
- **역할:** 업데이트가 발생하면 실제 DOM을 건드리기 전에, 이 가상의 복제판에 먼저 반영해 봅니다.

### 가상 돔의 동작 원리: "버퍼링(Buffering)"
만약 동시에 3개의 업데이트가 발생했다고 가정해 봅시다.
![[Virtual DOM 예시.png]]
1. **동시 업데이트 발생:** 실제 DOM 대신 자바스크립트 객체인 **가상 돔**에 먼저 업데이트들을 순서대로 반영합니다.
2. **업데이트 수집:** 가상 돔은 일종의 **버퍼(모아두는 장소)** 역할을 수행하며, 발생한 모든 변화를 차곡차곡 모읍니다.

![[Virtual DOM 예시2.png]]
3. **한 번에 반영:** 모든 업데이트가 다 모이면, 리액트는 바뀐 부분만 계산하여 **실제 DOM에 딱 한 번만 반영**합니다.

### 핵심 요약: 왜 리액트가 빠를까?
아까 직접 코드를 짰던 것처럼, 리액트는 아무리 많은 업데이트가 동시에 발생해도 **최소한의 횟수로 실제 돔을 수정**하도록 설계되어 있습니다.
- **자동 최적화:** 개발자가 일일이 "모아서 처리하기" 코드를 짤 필요가 없음
- **성능 보장:** 대부분의 상황에서 충분히 빠른 속도로 UI를 업데이트할 수 있도록 도와줌

## React Application?
> React로 만든 웹 서비스들은 보통 React App, React Application이라고 불립니다.

단순히 정보를 보여주는 웹페이지 수준을 넘어, 웹 브라우저 위에서 마치 스마트폰 앱처럼 복잡하고 다양한 상호작용을 제공하기 때문입니다.

### React App 생성하기
리액트 앱을 직접 구축하려면 보통 다음과 같은 과정을 거칩니다.
1. Node.js 패키지 생성
2. React 라이브러리 설치
3. 기타 도구 설치 및 설정

> 예전에는 설정을 위해 많은 시간을 썼지만, 최근에는 Vite라는 빌드 도구를 이용해 위 과정을 한 번에, 빠르게 처리할 수 있습니다.

### 주요 폴더 및 파일 구조
Vite로 리액트 앱을 생성하면 아래와 같은 파일들이 만들어집니다.
1. `index.html` (메인 입구)
  - 리액트 앱의 유일한 HTML 파일
  - 리액트가 만든 모든 UI 컴포넌트들이 이 위치에 '주입'되어 화면에 표시
2. `src` 폴더 (실제 개발 공간)
  - 우리가 작성할 소스 코드가 대부분 위치하는 곳
  - `main.jsx`: 리액트 앱의 시작점으로, 리액트 코드와 HTML의 `root` 태그를 연결해주는 역할
  - `App.jsx`: 실제 화면에 그려질 최상위 컴포넌트
3. `public` 폴더 (정적 자원 저장소)
  - 이미지, 폰트, 아이콘처럼 수정되지 않고 그대로 배포될 파일들을 보관
  - 이곳에 있는 파일은 브라우저에서 직접 접근 가능
4. `vite.config.js` (설정 파일)
  - Vite 빌드 도구의 옵션을 설정하는 파일

## React App 구동 원리 살펴보기
> 우리가 비트(Vite)로 만든 리액트 프로젝트를 실행할 때, 화면 뒤에서는 어떤 일이 벌어질까요?

### 1. 내장 웹 서버와 실행 명령어
비트로 생성한 프로젝트에는 개발을 도와주는 **웹 서버**가 내장되어 있습니다. 터미널에 아래 명령어를 입력하면 리액트 서버가 가동됩니다.
```Bash
npm run dev
```

명령어를 실행하면 터미널에 `http://localhost:5173` 같은 주소가 나타납니다. 여기서 숫자 **5173**은 무엇을 의미할까요?

### 2. 포트 번호(Port Number)란?
**주소 뒤에 붙는 고유 번호**로, 한 대의 컴퓨터 안에서 실행 중인 여러 프로그램(서버) 중 어떤 프로그램을 호출할지 결정하는 '문 번호'와 같습니다.

우리가 사용하는 컴퓨터(localhost) 안에는 리액트 서버뿐만 아니라 다른 서버들도 동시에 돌아갈 수 있습니다.
- **문제 발생**: `localhost`로만 접속한다면? 우리 컴퓨터는 리액트 서버가 응답해야 할지, 아니면 다른 서버(예: PHP 서버)가 응답해야 할지 알 수 없습니다.
- **해결 방법:** 그래서 각 프로그램이 실행될 때마다 고유한 **포트 번호**를 부여합니다.

### 3. 이해를 돕는 비유

| 용어         | 비유               | 설명                    |
| ---------- | ---------------- | --------------------- |
| localhost  | 아파트 건물           | 내 컴퓨터 자체를 의미하는 주소     |
| 5173, 3344 | 호수 (Room Number) | 건물 내 특정 집을 찾아가기 위한 번호 |
- **리액트 서버**: `localhost:5173`
- **PHP 서버**: `localhost:3344`

## 학습 내용 요약 및 고찰
본 포스팅에서는 Node.js의 기초 이론부터 React의 핵심 구동 메커니즘까지 전반적인 개요를 고찰하였습니다. 주요 학습 내용을 다음과 같이 요약합니다.

### 1. Node.js와 자바스크립트 실행 환경
- 자바스크립트를 브라우저 밖에서도 실행할 수 있게 해주는 **Node.js 환경**과 그 역할을 이해했습니다.
- 모듈과 라이브러리를 활용해 코드를 체계적으로 나누고 관리하는 방법을 확인했습니다.

### 2. 컴포넌트 기반 설계의 장점
- 화면을 독립적인 **컴포넌트** 단위로 나누어 개발함으로써, 코드를 재사용하기 쉽고 유지보수가 편리해지는 리액트의 핵심 방식을 이해했습니다.

### 3. 선언형 프로그래밍과 상태(State) 관리
- 과정을 일일이 설명하지 않아도 결과값(목적)만 명시하면 되는 **선언형 방식**의 편리함을 파악했습니다.
- **State(데이터)**가 바뀌면 화면이 알아서 업데이트되는 리액트의 구동 원리를 확인했습니다.

### 4. 가상 돔(Virtual DOM)을 통한 성능 최적화
- 브라우저가 화면을 그리는 과정(CRP)을 통해, 왜 직접적인 DOM 조작이 성능을 떨어뜨리는지 이해했습니다.
- **가상 돔**이 일종의 '모아두는 장소' 역할을 하여 실제 화면 수정을 최소화하고 성능을 높이는 과정을 확인했습니다.
